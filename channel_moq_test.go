// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package amqpx

import (
	"context"
	"github.com/rabbitmq/amqp091-go"
	"sync"
)

// Ensure, that ChannelMock does implement Channel.
// If this is not the case, regenerate this file with moq.
var _ Channel = &ChannelMock{}

// ChannelMock is a mock implementation of Channel.
//
// 	func TestSomethingThatUsesChannel(t *testing.T) {
//
// 		// make and configure a mocked Channel
// 		mockedChannel := &ChannelMock{
// 			CloseFunc: func() error {
// 				panic("mock out the Close method")
// 			},
// 			ConfirmFunc: func(noWait bool) error {
// 				panic("mock out the Confirm method")
// 			},
// 			ConsumeFunc: func(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error) {
// 				panic("mock out the Consume method")
// 			},
// 			ExchangeDeclareFunc: func(name string, kind string, durable bool, autoDelete bool, internal bool, noWait bool, args amqp091.Table) error {
// 				panic("mock out the ExchangeDeclare method")
// 			},
// 			NotifyCancelFunc: func(stringCh chan string) chan string {
// 				panic("mock out the NotifyCancel method")
// 			},
// 			NotifyCloseFunc: func(errorCh chan *amqp091.Error) chan *amqp091.Error {
// 				panic("mock out the NotifyClose method")
// 			},
// 			NotifyReturnFunc: func(c chan amqp091.Return) chan amqp091.Return {
// 				panic("mock out the NotifyReturn method")
// 			},
// 			PublishWithDeferredConfirmWithContextFunc: func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing) (*amqp091.DeferredConfirmation, error) {
// 				panic("mock out the PublishWithDeferredConfirmWithContext method")
// 			},
// 			QosFunc: func(prefetchCount int, prefetchSize int, global bool) error {
// 				panic("mock out the Qos method")
// 			},
// 			QueueBindFunc: func(name string, key string, exchange string, noWait bool, args amqp091.Table) error {
// 				panic("mock out the QueueBind method")
// 			},
// 			QueueDeclareFunc: func(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table) (amqp091.Queue, error) {
// 				panic("mock out the QueueDeclare method")
// 			},
// 		}
//
// 		// use mockedChannel in code that requires Channel
// 		// and then make assertions.
//
// 	}
type ChannelMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ConfirmFunc mocks the Confirm method.
	ConfirmFunc func(noWait bool) error

	// ConsumeFunc mocks the Consume method.
	ConsumeFunc func(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error)

	// ExchangeDeclareFunc mocks the ExchangeDeclare method.
	ExchangeDeclareFunc func(name string, kind string, durable bool, autoDelete bool, internal bool, noWait bool, args amqp091.Table) error

	// NotifyCancelFunc mocks the NotifyCancel method.
	NotifyCancelFunc func(stringCh chan string) chan string

	// NotifyCloseFunc mocks the NotifyClose method.
	NotifyCloseFunc func(errorCh chan *amqp091.Error) chan *amqp091.Error

	// NotifyReturnFunc mocks the NotifyReturn method.
	NotifyReturnFunc func(c chan amqp091.Return) chan amqp091.Return

	// PublishWithDeferredConfirmWithContextFunc mocks the PublishWithDeferredConfirmWithContext method.
	PublishWithDeferredConfirmWithContextFunc func(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing) (*amqp091.DeferredConfirmation, error)

	// QosFunc mocks the Qos method.
	QosFunc func(prefetchCount int, prefetchSize int, global bool) error

	// QueueBindFunc mocks the QueueBind method.
	QueueBindFunc func(name string, key string, exchange string, noWait bool, args amqp091.Table) error

	// QueueDeclareFunc mocks the QueueDeclare method.
	QueueDeclareFunc func(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table) (amqp091.Queue, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Confirm holds details about calls to the Confirm method.
		Confirm []struct {
			// NoWait is the noWait argument value.
			NoWait bool
		}
		// Consume holds details about calls to the Consume method.
		Consume []struct {
			// Queue is the queue argument value.
			Queue string
			// Consumer is the consumer argument value.
			Consumer string
			// AutoAck is the autoAck argument value.
			AutoAck bool
			// Exclusive is the exclusive argument value.
			Exclusive bool
			// NoLocal is the noLocal argument value.
			NoLocal bool
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp091.Table
		}
		// ExchangeDeclare holds details about calls to the ExchangeDeclare method.
		ExchangeDeclare []struct {
			// Name is the name argument value.
			Name string
			// Kind is the kind argument value.
			Kind string
			// Durable is the durable argument value.
			Durable bool
			// AutoDelete is the autoDelete argument value.
			AutoDelete bool
			// Internal is the internal argument value.
			Internal bool
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp091.Table
		}
		// NotifyCancel holds details about calls to the NotifyCancel method.
		NotifyCancel []struct {
			// StringCh is the stringCh argument value.
			StringCh chan string
		}
		// NotifyClose holds details about calls to the NotifyClose method.
		NotifyClose []struct {
			// ErrorCh is the errorCh argument value.
			ErrorCh chan *amqp091.Error
		}
		// NotifyReturn holds details about calls to the NotifyReturn method.
		NotifyReturn []struct {
			// C is the c argument value.
			C chan amqp091.Return
		}
		// PublishWithDeferredConfirmWithContext holds details about calls to the PublishWithDeferredConfirmWithContext method.
		PublishWithDeferredConfirmWithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Exchange is the exchange argument value.
			Exchange string
			// Key is the key argument value.
			Key string
			// Mandatory is the mandatory argument value.
			Mandatory bool
			// Immediate is the immediate argument value.
			Immediate bool
			// Msg is the msg argument value.
			Msg amqp091.Publishing
		}
		// Qos holds details about calls to the Qos method.
		Qos []struct {
			// PrefetchCount is the prefetchCount argument value.
			PrefetchCount int
			// PrefetchSize is the prefetchSize argument value.
			PrefetchSize int
			// Global is the global argument value.
			Global bool
		}
		// QueueBind holds details about calls to the QueueBind method.
		QueueBind []struct {
			// Name is the name argument value.
			Name string
			// Key is the key argument value.
			Key string
			// Exchange is the exchange argument value.
			Exchange string
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp091.Table
		}
		// QueueDeclare holds details about calls to the QueueDeclare method.
		QueueDeclare []struct {
			// Name is the name argument value.
			Name string
			// Durable is the durable argument value.
			Durable bool
			// AutoDelete is the autoDelete argument value.
			AutoDelete bool
			// Exclusive is the exclusive argument value.
			Exclusive bool
			// NoWait is the noWait argument value.
			NoWait bool
			// Args is the args argument value.
			Args amqp091.Table
		}
	}
	lockClose                                 sync.RWMutex
	lockConfirm                               sync.RWMutex
	lockConsume                               sync.RWMutex
	lockExchangeDeclare                       sync.RWMutex
	lockNotifyCancel                          sync.RWMutex
	lockNotifyClose                           sync.RWMutex
	lockNotifyReturn                          sync.RWMutex
	lockPublishWithDeferredConfirmWithContext sync.RWMutex
	lockQos                                   sync.RWMutex
	lockQueueBind                             sync.RWMutex
	lockQueueDeclare                          sync.RWMutex
}

// Close calls CloseFunc.
func (mock *ChannelMock) Close() error {
	if mock.CloseFunc == nil {
		panic("ChannelMock.CloseFunc: method is nil but Channel.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedChannel.CloseCalls())
func (mock *ChannelMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Confirm calls ConfirmFunc.
func (mock *ChannelMock) Confirm(noWait bool) error {
	if mock.ConfirmFunc == nil {
		panic("ChannelMock.ConfirmFunc: method is nil but Channel.Confirm was just called")
	}
	callInfo := struct {
		NoWait bool
	}{
		NoWait: noWait,
	}
	mock.lockConfirm.Lock()
	mock.calls.Confirm = append(mock.calls.Confirm, callInfo)
	mock.lockConfirm.Unlock()
	return mock.ConfirmFunc(noWait)
}

// ConfirmCalls gets all the calls that were made to Confirm.
// Check the length with:
//     len(mockedChannel.ConfirmCalls())
func (mock *ChannelMock) ConfirmCalls() []struct {
	NoWait bool
} {
	var calls []struct {
		NoWait bool
	}
	mock.lockConfirm.RLock()
	calls = mock.calls.Confirm
	mock.lockConfirm.RUnlock()
	return calls
}

// Consume calls ConsumeFunc.
func (mock *ChannelMock) Consume(queue string, consumer string, autoAck bool, exclusive bool, noLocal bool, noWait bool, args amqp091.Table) (<-chan amqp091.Delivery, error) {
	if mock.ConsumeFunc == nil {
		panic("ChannelMock.ConsumeFunc: method is nil but Channel.Consume was just called")
	}
	callInfo := struct {
		Queue     string
		Consumer  string
		AutoAck   bool
		Exclusive bool
		NoLocal   bool
		NoWait    bool
		Args      amqp091.Table
	}{
		Queue:     queue,
		Consumer:  consumer,
		AutoAck:   autoAck,
		Exclusive: exclusive,
		NoLocal:   noLocal,
		NoWait:    noWait,
		Args:      args,
	}
	mock.lockConsume.Lock()
	mock.calls.Consume = append(mock.calls.Consume, callInfo)
	mock.lockConsume.Unlock()
	return mock.ConsumeFunc(queue, consumer, autoAck, exclusive, noLocal, noWait, args)
}

// ConsumeCalls gets all the calls that were made to Consume.
// Check the length with:
//     len(mockedChannel.ConsumeCalls())
func (mock *ChannelMock) ConsumeCalls() []struct {
	Queue     string
	Consumer  string
	AutoAck   bool
	Exclusive bool
	NoLocal   bool
	NoWait    bool
	Args      amqp091.Table
} {
	var calls []struct {
		Queue     string
		Consumer  string
		AutoAck   bool
		Exclusive bool
		NoLocal   bool
		NoWait    bool
		Args      amqp091.Table
	}
	mock.lockConsume.RLock()
	calls = mock.calls.Consume
	mock.lockConsume.RUnlock()
	return calls
}

// ExchangeDeclare calls ExchangeDeclareFunc.
func (mock *ChannelMock) ExchangeDeclare(name string, kind string, durable bool, autoDelete bool, internal bool, noWait bool, args amqp091.Table) error {
	if mock.ExchangeDeclareFunc == nil {
		panic("ChannelMock.ExchangeDeclareFunc: method is nil but Channel.ExchangeDeclare was just called")
	}
	callInfo := struct {
		Name       string
		Kind       string
		Durable    bool
		AutoDelete bool
		Internal   bool
		NoWait     bool
		Args       amqp091.Table
	}{
		Name:       name,
		Kind:       kind,
		Durable:    durable,
		AutoDelete: autoDelete,
		Internal:   internal,
		NoWait:     noWait,
		Args:       args,
	}
	mock.lockExchangeDeclare.Lock()
	mock.calls.ExchangeDeclare = append(mock.calls.ExchangeDeclare, callInfo)
	mock.lockExchangeDeclare.Unlock()
	return mock.ExchangeDeclareFunc(name, kind, durable, autoDelete, internal, noWait, args)
}

// ExchangeDeclareCalls gets all the calls that were made to ExchangeDeclare.
// Check the length with:
//     len(mockedChannel.ExchangeDeclareCalls())
func (mock *ChannelMock) ExchangeDeclareCalls() []struct {
	Name       string
	Kind       string
	Durable    bool
	AutoDelete bool
	Internal   bool
	NoWait     bool
	Args       amqp091.Table
} {
	var calls []struct {
		Name       string
		Kind       string
		Durable    bool
		AutoDelete bool
		Internal   bool
		NoWait     bool
		Args       amqp091.Table
	}
	mock.lockExchangeDeclare.RLock()
	calls = mock.calls.ExchangeDeclare
	mock.lockExchangeDeclare.RUnlock()
	return calls
}

// NotifyCancel calls NotifyCancelFunc.
func (mock *ChannelMock) NotifyCancel(stringCh chan string) chan string {
	if mock.NotifyCancelFunc == nil {
		panic("ChannelMock.NotifyCancelFunc: method is nil but Channel.NotifyCancel was just called")
	}
	callInfo := struct {
		StringCh chan string
	}{
		StringCh: stringCh,
	}
	mock.lockNotifyCancel.Lock()
	mock.calls.NotifyCancel = append(mock.calls.NotifyCancel, callInfo)
	mock.lockNotifyCancel.Unlock()
	return mock.NotifyCancelFunc(stringCh)
}

// NotifyCancelCalls gets all the calls that were made to NotifyCancel.
// Check the length with:
//     len(mockedChannel.NotifyCancelCalls())
func (mock *ChannelMock) NotifyCancelCalls() []struct {
	StringCh chan string
} {
	var calls []struct {
		StringCh chan string
	}
	mock.lockNotifyCancel.RLock()
	calls = mock.calls.NotifyCancel
	mock.lockNotifyCancel.RUnlock()
	return calls
}

// NotifyClose calls NotifyCloseFunc.
func (mock *ChannelMock) NotifyClose(errorCh chan *amqp091.Error) chan *amqp091.Error {
	if mock.NotifyCloseFunc == nil {
		panic("ChannelMock.NotifyCloseFunc: method is nil but Channel.NotifyClose was just called")
	}
	callInfo := struct {
		ErrorCh chan *amqp091.Error
	}{
		ErrorCh: errorCh,
	}
	mock.lockNotifyClose.Lock()
	mock.calls.NotifyClose = append(mock.calls.NotifyClose, callInfo)
	mock.lockNotifyClose.Unlock()
	return mock.NotifyCloseFunc(errorCh)
}

// NotifyCloseCalls gets all the calls that were made to NotifyClose.
// Check the length with:
//     len(mockedChannel.NotifyCloseCalls())
func (mock *ChannelMock) NotifyCloseCalls() []struct {
	ErrorCh chan *amqp091.Error
} {
	var calls []struct {
		ErrorCh chan *amqp091.Error
	}
	mock.lockNotifyClose.RLock()
	calls = mock.calls.NotifyClose
	mock.lockNotifyClose.RUnlock()
	return calls
}

// NotifyReturn calls NotifyReturnFunc.
func (mock *ChannelMock) NotifyReturn(c chan amqp091.Return) chan amqp091.Return {
	if mock.NotifyReturnFunc == nil {
		panic("ChannelMock.NotifyReturnFunc: method is nil but Channel.NotifyReturn was just called")
	}
	callInfo := struct {
		C chan amqp091.Return
	}{
		C: c,
	}
	mock.lockNotifyReturn.Lock()
	mock.calls.NotifyReturn = append(mock.calls.NotifyReturn, callInfo)
	mock.lockNotifyReturn.Unlock()
	return mock.NotifyReturnFunc(c)
}

// NotifyReturnCalls gets all the calls that were made to NotifyReturn.
// Check the length with:
//     len(mockedChannel.NotifyReturnCalls())
func (mock *ChannelMock) NotifyReturnCalls() []struct {
	C chan amqp091.Return
} {
	var calls []struct {
		C chan amqp091.Return
	}
	mock.lockNotifyReturn.RLock()
	calls = mock.calls.NotifyReturn
	mock.lockNotifyReturn.RUnlock()
	return calls
}

// PublishWithDeferredConfirmWithContext calls PublishWithDeferredConfirmWithContextFunc.
func (mock *ChannelMock) PublishWithDeferredConfirmWithContext(ctx context.Context, exchange string, key string, mandatory bool, immediate bool, msg amqp091.Publishing) (*amqp091.DeferredConfirmation, error) {
	if mock.PublishWithDeferredConfirmWithContextFunc == nil {
		panic("ChannelMock.PublishWithDeferredConfirmWithContextFunc: method is nil but Channel.PublishWithDeferredConfirmWithContext was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Exchange  string
		Key       string
		Mandatory bool
		Immediate bool
		Msg       amqp091.Publishing
	}{
		Ctx:       ctx,
		Exchange:  exchange,
		Key:       key,
		Mandatory: mandatory,
		Immediate: immediate,
		Msg:       msg,
	}
	mock.lockPublishWithDeferredConfirmWithContext.Lock()
	mock.calls.PublishWithDeferredConfirmWithContext = append(mock.calls.PublishWithDeferredConfirmWithContext, callInfo)
	mock.lockPublishWithDeferredConfirmWithContext.Unlock()
	return mock.PublishWithDeferredConfirmWithContextFunc(ctx, exchange, key, mandatory, immediate, msg)
}

// PublishWithDeferredConfirmWithContextCalls gets all the calls that were made to PublishWithDeferredConfirmWithContext.
// Check the length with:
//     len(mockedChannel.PublishWithDeferredConfirmWithContextCalls())
func (mock *ChannelMock) PublishWithDeferredConfirmWithContextCalls() []struct {
	Ctx       context.Context
	Exchange  string
	Key       string
	Mandatory bool
	Immediate bool
	Msg       amqp091.Publishing
} {
	var calls []struct {
		Ctx       context.Context
		Exchange  string
		Key       string
		Mandatory bool
		Immediate bool
		Msg       amqp091.Publishing
	}
	mock.lockPublishWithDeferredConfirmWithContext.RLock()
	calls = mock.calls.PublishWithDeferredConfirmWithContext
	mock.lockPublishWithDeferredConfirmWithContext.RUnlock()
	return calls
}

// Qos calls QosFunc.
func (mock *ChannelMock) Qos(prefetchCount int, prefetchSize int, global bool) error {
	if mock.QosFunc == nil {
		panic("ChannelMock.QosFunc: method is nil but Channel.Qos was just called")
	}
	callInfo := struct {
		PrefetchCount int
		PrefetchSize  int
		Global        bool
	}{
		PrefetchCount: prefetchCount,
		PrefetchSize:  prefetchSize,
		Global:        global,
	}
	mock.lockQos.Lock()
	mock.calls.Qos = append(mock.calls.Qos, callInfo)
	mock.lockQos.Unlock()
	return mock.QosFunc(prefetchCount, prefetchSize, global)
}

// QosCalls gets all the calls that were made to Qos.
// Check the length with:
//     len(mockedChannel.QosCalls())
func (mock *ChannelMock) QosCalls() []struct {
	PrefetchCount int
	PrefetchSize  int
	Global        bool
} {
	var calls []struct {
		PrefetchCount int
		PrefetchSize  int
		Global        bool
	}
	mock.lockQos.RLock()
	calls = mock.calls.Qos
	mock.lockQos.RUnlock()
	return calls
}

// QueueBind calls QueueBindFunc.
func (mock *ChannelMock) QueueBind(name string, key string, exchange string, noWait bool, args amqp091.Table) error {
	if mock.QueueBindFunc == nil {
		panic("ChannelMock.QueueBindFunc: method is nil but Channel.QueueBind was just called")
	}
	callInfo := struct {
		Name     string
		Key      string
		Exchange string
		NoWait   bool
		Args     amqp091.Table
	}{
		Name:     name,
		Key:      key,
		Exchange: exchange,
		NoWait:   noWait,
		Args:     args,
	}
	mock.lockQueueBind.Lock()
	mock.calls.QueueBind = append(mock.calls.QueueBind, callInfo)
	mock.lockQueueBind.Unlock()
	return mock.QueueBindFunc(name, key, exchange, noWait, args)
}

// QueueBindCalls gets all the calls that were made to QueueBind.
// Check the length with:
//     len(mockedChannel.QueueBindCalls())
func (mock *ChannelMock) QueueBindCalls() []struct {
	Name     string
	Key      string
	Exchange string
	NoWait   bool
	Args     amqp091.Table
} {
	var calls []struct {
		Name     string
		Key      string
		Exchange string
		NoWait   bool
		Args     amqp091.Table
	}
	mock.lockQueueBind.RLock()
	calls = mock.calls.QueueBind
	mock.lockQueueBind.RUnlock()
	return calls
}

// QueueDeclare calls QueueDeclareFunc.
func (mock *ChannelMock) QueueDeclare(name string, durable bool, autoDelete bool, exclusive bool, noWait bool, args amqp091.Table) (amqp091.Queue, error) {
	if mock.QueueDeclareFunc == nil {
		panic("ChannelMock.QueueDeclareFunc: method is nil but Channel.QueueDeclare was just called")
	}
	callInfo := struct {
		Name       string
		Durable    bool
		AutoDelete bool
		Exclusive  bool
		NoWait     bool
		Args       amqp091.Table
	}{
		Name:       name,
		Durable:    durable,
		AutoDelete: autoDelete,
		Exclusive:  exclusive,
		NoWait:     noWait,
		Args:       args,
	}
	mock.lockQueueDeclare.Lock()
	mock.calls.QueueDeclare = append(mock.calls.QueueDeclare, callInfo)
	mock.lockQueueDeclare.Unlock()
	return mock.QueueDeclareFunc(name, durable, autoDelete, exclusive, noWait, args)
}

// QueueDeclareCalls gets all the calls that were made to QueueDeclare.
// Check the length with:
//     len(mockedChannel.QueueDeclareCalls())
func (mock *ChannelMock) QueueDeclareCalls() []struct {
	Name       string
	Durable    bool
	AutoDelete bool
	Exclusive  bool
	NoWait     bool
	Args       amqp091.Table
} {
	var calls []struct {
		Name       string
		Durable    bool
		AutoDelete bool
		Exclusive  bool
		NoWait     bool
		Args       amqp091.Table
	}
	mock.lockQueueDeclare.RLock()
	calls = mock.calls.QueueDeclare
	mock.lockQueueDeclare.RUnlock()
	return calls
}
